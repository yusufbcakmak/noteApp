#!/usr/bin/env node

/**
 * CLI script for API consistency validation between frontend and backend
 */

const ApiConsistencyValidator = require('../utils/apiConsistencyValidator');
const MockServer = require('../utils/mockServer');
const logger = require('../utils/logger');

/**
 * CLI command handler for API consistency validation
 */
class ApiConsistencyValidatorCLI {
  constructor() {
    this.validator = new ApiConsistencyValidator();
    this.mockServer = new MockServer();
  }

  /**
   * Validate API consistency
   */
  async validateConsistency(options = {}) {
    try {
      logger.info('Starting API consistency validation...');
      
      await this.validator.init();
      
      // Scan frontend code for API calls
      const frontendPath = options.frontendPath || 'frontend/src';
      await this.validator.scanFrontendApiCalls(frontendPath);
      
      // Validate consistency
      const inconsistencies = await this.validator.validateConsistency();
      
      // Generate reports
      const jsonReport = await this.validator.saveReport(options.jsonOutput || 'api-consistency-report.json');
      const mdReport = await this.validator.saveHumanReadableReport(options.mdOutput || 'api-consistency-report.md');
      
      // Log summary
      const report = this.validator.generateReport();
      logger.info('API consistency validation completed');
      logger.info(`Frontend API calls: ${report.summary.totalFrontendCalls}`);
      logger.info(`Backend endpoints: ${report.summary.totalBackendEndpoints}`);
      logger.info(`Issues found: ${report.summary.totalInconsistencies}`);
      logger.info(`- Errors: ${report.summary.errorCount}`);
      logger.info(`- Warnings: ${report.summary.warningCount}`);
      logger.info(`Reports saved: ${jsonReport}, ${mdReport}`);
      
      return {
        success: true,
        report,
        jsonReport,
        mdReport
      };
    } catch (error) {
      logger.error('API consistency validation failed:', error);
      throw error;
    }
  }

  /**
   * Start mock server
   */
  async startMockServer(options = {}) {
    try {
      logger.info('Starting mock server...');
      
      const port = options.port || 3001;
      this.mockServer.port = port;
      
      await this.mockServer.start();
      
      logger.info(`Mock server started on http://localhost:${port}`);
      logger.info('Available endpoints:');
      logger.info('- GET / - Server info');
      logger.info('- GET /mock/requests - Request log');
      logger.info('- GET /mock/data - Mock data');
      logger.info('- POST /api/auth/login - Login');
      logger.info('- POST /api/auth/register - Register');
      logger.info('- GET /api/notes - Get notes');
      logger.info('- POST /api/notes - Create note');
      logger.info('- GET /api/groups - Get groups');
      logger.info('- POST /api/groups - Create group');
      
      return this.mockServer;
    } catch (error) {
      logger.error('Failed to start mock server:', error);
      throw error;
    }
  }

  /**
   * Stop mock server
   */
  async stopMockServer() {
    try {
      await this.mockServer.stop();
      logger.info('Mock server stopped');
    } catch (error) {
      logger.error('Failed to stop mock server:', error);
      throw error;
    }
  }

  /**
   * Generate frontend API client
   */
  async generateApiClient(options = {}) {
    try {
      logger.info('Generating frontend API client...');
      
      await this.validator.init();
      
      const clientCode = this.generateTypeScriptApiClient();
      const outputPath = options.output || 'frontend/src/services/apiClient.ts';
      
      const fs = require('fs').promises;
      const path = require('path');
      
      // Ensure output directory exists
      const outputDir = path.dirname(outputPath);
      await fs.mkdir(outputDir, { recursive: true });
      
      await fs.writeFile(outputPath, clientCode, 'utf8');
      
      logger.info(`API client generated: ${outputPath}`);
      
      return outputPath;
    } catch (error) {
      logger.error('Failed to generate API client:', error);
      throw error;
    }
  }

  /**
   * Generate TypeScript API client code
   */
  generateTypeScriptApiClient() {
    const spec = this.validator.spec;
    
    let clientCode = `/**
 * Auto-generated API client from OpenAPI specification
 * Generated on: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 */

import { ApiResponse, PaginatedResponse } from '../types/api';

export interface ApiClientConfig {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
}

export class ApiClient {
  private baseURL: string;
  private timeout: number;
  private defaultHeaders: Record<string, string>;
  private token: string | null = null;

  constructor(config: ApiClientConfig = {}) {
    this.baseURL = config.baseURL || 'http://localhost:3000';
    this.timeout = config.timeout || 10000;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...config.headers
    };
  }

  /**
   * Set authentication token
   */
  setToken(token: string) {
    this.token = token;
  }

  /**
   * Clear authentication token
   */
  clearToken() {
    this.token = null;
  }

  /**
   * Make HTTP request
   */
  private async request<T = any>(
    method: string,
    path: string,
    options: {
      params?: Record<string, any>;
      data?: any;
      headers?: Record<string, string>;
    } = {}
  ): Promise<ApiResponse<T>> {
    const url = new URL(path, this.baseURL);
    
    // Add query parameters
    if (options.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    const headers = {
      ...this.defaultHeaders,
      ...options.headers
    };

    // Add authorization header if token is set
    if (this.token) {
      headers.Authorization = \`Bearer \${this.token}\`;
    }

    const requestOptions: RequestInit = {
      method,
      headers,
    };

    // Add request body for non-GET requests
    if (options.data && method !== 'GET') {
      requestOptions.body = JSON.stringify(options.data);
    }

    try {
      const response = await fetch(url.toString(), requestOptions);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error?.message || \`HTTP \${response.status}\`);
      }

      return data;
    } catch (error) {
      throw new Error(\`API request failed: \${error.message}\`);
    }
  }

  // Authentication methods
  async login(credentials: { email: string; password: string }) {
    return this.request('POST', '/api/auth/login', { data: credentials });
  }

  async register(userData: { email: string; password: string; firstName: string; lastName: string }) {
    return this.request('POST', '/api/auth/register', { data: userData });
  }

  async getCurrentUser() {
    return this.request('GET', '/api/auth/me');
  }

  // Notes methods
  async getNotes(params?: {
    page?: number;
    limit?: number;
    status?: string;
    priority?: string;
    groupId?: string;
    search?: string;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse> {
    return this.request('GET', '/api/notes', { params });
  }

  async createNote(noteData: {
    title: string;
    description?: string;
    priority?: string;
    groupId?: string;
  }) {
    return this.request('POST', '/api/notes', { data: noteData });
  }

  async getNote(id: string) {
    return this.request('GET', \`/api/notes/\${id}\`);
  }

  async updateNote(id: string, updates: {
    title?: string;
    description?: string;
    status?: string;
    priority?: string;
    groupId?: string;
  }) {
    return this.request('PUT', \`/api/notes/\${id}\`, { data: updates });
  }

  async deleteNote(id: string) {
    return this.request('DELETE', \`/api/notes/\${id}\`);
  }

  async updateNoteStatus(id: string, status: string) {
    return this.request('PATCH', \`/api/notes/\${id}/status\`, { data: { status } });
  }

  // Groups methods
  async getGroups(params?: {
    page?: number;
    limit?: number;
    search?: string;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse> {
    return this.request('GET', '/api/groups', { params });
  }

  async createGroup(groupData: {
    name: string;
    description?: string;
    color?: string;
  }) {
    return this.request('POST', '/api/groups', { data: groupData });
  }

  async getGroup(id: string) {
    return this.request('GET', \`/api/groups/\${id}\`);
  }

  async updateGroup(id: string, updates: {
    name?: string;
    description?: string;
    color?: string;
  }) {
    return this.request('PUT', \`/api/groups/\${id}\`, { data: updates });
  }

  async deleteGroup(id: string) {
    return this.request('DELETE', \`/api/groups/\${id}\`);
  }

  // History methods
  async getHistory(params?: {
    page?: number;
    limit?: number;
    startDate?: string;
    endDate?: string;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse> {
    return this.request('GET', '/api/history', { params });
  }

  async getDailyStats(params?: {
    date?: string;
    days?: number;
  }) {
    return this.request('GET', '/api/history/daily', { params });
  }

  // User methods
  async getUserProfile() {
    return this.request('GET', '/api/user/profile');
  }

  async updateUserProfile(updates: {
    firstName?: string;
    lastName?: string;
    email?: string;
    currentPassword?: string;
    newPassword?: string;
  }) {
    return this.request('PUT', '/api/user/profile', { data: updates });
  }

  async deleteAccount(confirmation: {
    password: string;
    confirmation: string;
  }) {
    return this.request('DELETE', '/api/user/account', { data: confirmation });
  }
}

// Create default instance
export const apiClient = new ApiClient();

export default apiClient;
`;

    return clientCode;
  }

  /**
   * Test API consistency with mock server
   */
  async testWithMockServer(options = {}) {
    try {
      logger.info('Testing API consistency with mock server...');
      
      // Start mock server
      const mockServer = await this.startMockServer({ port: options.mockPort || 3001 });
      
      // Wait a bit for server to be ready
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Run consistency validation
      const result = await this.validateConsistency(options);
      
      // Test some endpoints
      const testResults = await this.runEndpointTests(options.mockPort || 3001);
      
      // Stop mock server
      await this.stopMockServer();
      
      return {
        ...result,
        mockServerTests: testResults
      };
    } catch (error) {
      // Make sure to stop mock server on error
      try {
        await this.stopMockServer();
      } catch (stopError) {
        logger.warn('Failed to stop mock server:', stopError);
      }
      
      logger.error('Mock server testing failed:', error);
      throw error;
    }
  }

  /**
   * Run endpoint tests against mock server
   */
  async runEndpointTests(port) {
    const baseURL = `http://localhost:${port}`;
    const testResults = [];

    try {
      // Test server info
      const infoResponse = await fetch(`${baseURL}/`);
      const infoData = await infoResponse.json();
      testResults.push({
        endpoint: 'GET /',
        status: infoResponse.status,
        success: infoResponse.ok,
        data: infoData
      });

      // Test login
      const loginResponse = await fetch(`${baseURL}/api/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'john.doe@example.com',
          password: 'password123'
        })
      });
      const loginData = await loginResponse.json();
      testResults.push({
        endpoint: 'POST /api/auth/login',
        status: loginResponse.status,
        success: loginResponse.ok,
        data: loginData
      });

      // Test notes with auth token
      if (loginData.success && loginData.data.token) {
        const notesResponse = await fetch(`${baseURL}/api/notes`, {
          headers: {
            'Authorization': `Bearer ${loginData.data.token}`
          }
        });
        const notesData = await notesResponse.json();
        testResults.push({
          endpoint: 'GET /api/notes',
          status: notesResponse.status,
          success: notesResponse.ok,
          data: notesData
        });
      }

    } catch (error) {
      testResults.push({
        endpoint: 'Test execution',
        success: false,
        error: error.message
      });
    }

    return testResults;
  }
}

/**
 * CLI interface
 */
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  
  const cli = new ApiConsistencyValidatorCLI();

  try {
    switch (command) {
      case 'validate':
        await cli.validateConsistency({
          frontendPath: args[1] || 'frontend/src',
          jsonOutput: args[2] || 'api-consistency-report.json',
          mdOutput: args[3] || 'api-consistency-report.md'
        });
        break;
        
      case 'mock-server':
        const port = parseInt(args[1]) || 3001;
        await cli.startMockServer({ port });
        
        // Keep server running until interrupted
        process.on('SIGINT', async () => {
          logger.info('Shutting down mock server...');
          await cli.stopMockServer();
          process.exit(0);
        });
        
        // Keep process alive
        await new Promise(() => {});
        break;
        
      case 'generate-client':
        await cli.generateApiClient({
          output: args[1] || 'frontend/src/services/apiClient.ts'
        });
        break;
        
      case 'test':
        await cli.testWithMockServer({
          mockPort: parseInt(args[1]) || 3001,
          frontendPath: args[2] || 'frontend/src'
        });
        break;
        
      default:
        console.log('Usage:');
        console.log('  validate [frontend-path] [json-output] [md-output] - Validate API consistency');
        console.log('  mock-server [port] - Start mock server');
        console.log('  generate-client [output-path] - Generate TypeScript API client');
        console.log('  test [mock-port] [frontend-path] - Test with mock server');
        break;
    }
  } catch (error) {
    logger.error('Command failed:', error);
    process.exit(1);
  }
}

// Run CLI if called directly
if (require.main === module) {
  main();
}

module.exports = ApiConsistencyValidatorCLI;